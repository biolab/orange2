<html>
<HEAD>
<LINK REL=StyleSheet HREF="style.css" TYPE="text/css" MEDIA=screen>
<LINK REL=StyleSheet HREF="style-print.css" TYPE="text/css" MEDIA=print>
</HEAD>

<BODY>
<h1>Loading Data from Files</h1>

<P>Orange reads and writes files in a number of different formats.
<DL>
<DT><B>C4.5</B></DT>
<DD>A format used in Quinlan's system C45; the system is a standard benchmark and the file format is one of the most widely formats in machine learning. It uses at least two files, &lt;stem&gt;.names contains descriptions of attributes and &lt;stem&gt;.data contains learning examples. If so requested, C4.5 also reads a file &lt;stem&gt;.test with testing examples. The details about the format can be found on Quinlan's web pages. This format is not the same as C5 (aka See5). C5's format is rather complex and only a limited support is planned for some future release of Orange. There's no point in supporting a format that allows specification of all kinds of transformations is these can be done in Python scripts.</DD>

<DT><B>Assistant</B></DT>
<DD>Assistant format is used by a family of Assistant systems, state-of-the-art tree induction systems that were developed in 80s and early 90s on Jozef Stefan Institute in Ljubljana, Slovenia. The data is stored in two files, ASDO&lt;stem&gt;.DAT containing the attribute descriptions and ASDA&lt;stem&gt;.DAT containing the data. Details can be found in documentation for any version of Assistant.</DD>

<DT><B>Retis</B></DT>
<DD>Retis is another older product of Jozef Stefan Institute, this one for induction of regression trees. The file format thus supports only continuous outcomes. The description of attributes is stored in &lt;stem&gt;.rdo and the data in &lt;stem&gt;.rda. Details can be found in Retis documentation.</DD>

<DT><B><a href="tabdelimited.htm">Tab-delimited</a></B></DT>
<DD>An easy-to-use, yet powerful native Orange file format. Both, domain description and examples are stored in the same file. It comes in two flavors. In the older version, the first three lines contain names of the attributes, their values and optional flags, respectively. In newer, the first line contains attribute names whose prefixes describe the attribute types and optional flags - the prefixes need only be given in special occasions, while in general the parser will guess the attribute types itself. In both flavors, the remaining lines contain examples. Fields are delimited by tabulators. Detailed description is given in a page on <a href="tabdelimited.htm">tab-delimited formats</a>.</DD>

<DT><B><a href="tabdelimited.htm">Comma-separated</a></B></DT>
<DD>The format itself is similar to the new-favor <a href="tabdelimited.htm">tab-delimited formats</a>: the first line lists attribute names and the remaining lines contain values, separated by commas. Spaces are trimmed. Additional specifiers can be prefixed to the attribute names.</DD>

<DT><B><a href="basket.htm">Basket</a></B></DT>
<DD>Basket format is suitable for storing sparse examples. These are not described by the usual list of values of attributes whose order is defined in domain descriptor. Instead, all values are written as meta-attributes. Examples in such format can be used for derivation of association rules; if you want to use them for any other purpose, you need to convert them into "ordinary" examples by pulling some meta-attributes into ordinary attributes. At the moment, this file format is limited to continuous attributes only.</DD>

<DT><B><a href="tabdelimited.htm">Excel</a></B></DT>
<DD>This format is only available on Windows. Besides, you need to have Excel installed in order for Orange to be able to read those files. Besides besides, Orange occasionally hangs during communication with Excel, for an unknown reason. The file format is generally the same as the second flavor of <a href="tabdelimited.htm">tab-delimited files</a>, except that tab-separated entries in the former are here substituted by spreadsheet's cells. This format is read-only, for now; if you want to output the file by Orange and then process it with Excel, you can use tab-delimited files.</DD>
</DL>

<H2>Loading Examples</H2>

<P>Loading examples is trivial. To load the data from the file <CODE>iris.tab</CODE>, you simply type</P>

<XMP class="code">
>>> data = orange.ExampleTable("iris.tab")
</XMP>

<P>You can, of course, also give a relative or absolute path to the file. Well, <CODE>ExampleTable</CODE> is even smarted than that. You can omit the file extension.</P>

<XMP class="code">
>>> data = orange.ExampleTable("iris")
</XMP>

<P>This will do the same - Orange will look for any file with stem "iris" and a recognizable extension, such as .tab, .names, .rda... What happens when there is more than one such file? If orange discovers that you have, for instance, iris.tab <EM>and</EM> iris.names in the current directory, it will issue an error. You will have to provide the extension in this case.</P>

<P>But there's more. You don't even have to provide a filename. If you call the <CODE>ExampleTable</CODE> without any arguments, like this,</P>

<XMP class="code">
>>> data = orange.ExampleTable("")
</XMP>

<P>it will load the file with the same name as the current directory name. So, if your current directory is "c:\mydata\iris", it will look for files with stem "iris" and any known extensions. This might come handy if you perform some massive experiments and you want to run the same script for many different datasets located in separate directories.</P>

<P>There's a special trick for reading Excel files. If the file has multiple worksheets, the active worksheet (the one which was visible when the file was last saved) is read. To override this, you can specify a worksheet by appending a "#" and the worksheet's name to the file name. If your iris file is in Excel's format in a worksheet named "train", you can read it by

<XMP class="code">
>>> data = orange.ExampleTable("iris#train")
</XMP>


<H2>Multiple Datafiles with the Same Domain</H2>

<P>Special mechanisms are at work when you have, for instance, separate files for training and testing examples, but with the same attribute names and types in the same order.</P>

<XMP class="code">
>>> train = orange.ExampleTable("iris_train")
>>> test = orange.ExampleTable("iris_test")
</XMP>

<P>When loading the first file, Orange constructs a corresponding <a href="Domain.htm">domain</A> with descriptions of attributes. When it loads the second file, it notices that the attribute names, types and their order is the (same). In such a case it reuses the existing domain instead of constructing a new one. An old domain can be reused if all the names, types and order of the attributes matches, together with the class attribute if present. Order of meta-attributes is not important. Reuse is restricted to domains coming from the same file-format; when reading C4.5 files, only domains constructed from C4.5 files are checked for potential reuse. It is possible to explicitly tell Orange to reuse another domain, though (see below).<P>

<P>A situtation that would probably occur even more often is to have an Excel file with two spreadsheets, one containing training and the other testing examples. They can be loaded by:</P>

<XMP class="code">
>>> train = orange.ExampleTable("breast.xls#train")
>>> test = orange.ExampleTable("breast.xls#test")
</XMP>

<P>The purpose of reuse is far beyond saving a little space. If new attribute descriptors were constructed for each file, the attributes in the two datasets would have same names, but would be treated as different attributes. Orange does not distinguish attributes by names but by descriptors. Names are there for your eyes only. Classifier induced from dataset <CODE>iris_train</CODE> wouldn't recognize attributes from dataset <CODE>iris_test</CODE> if there was no reuse.</P>

<P>You can override the default behaviour by adding a few keyword parameters. You can prohibit reusing domains by setting <code>dontCheckStored</code> to 1. Therefore, if you would, for any weird reason, want to have the above iris datasets belonging to two unrelated domains, you can load them by</p>

<XMP class="code">
>>> train = orange.ExampleTable("iris.data")
>>> test = orange.ExampleTable("iris.test", dontCheckStored = 1)
</XMP>

<P>Similarly, you can prohibit storing a domain by setting <code>dontStore</code> to 1. This way, the domain will never be reused at further loading.</p>

<p>You can give the <code>ExampleTable</code> a list of attributes that can be reused. For instance, you might have testing set that contains some attributes not present in the training set. By the usual mechanism, these datasets would have separate domain and attribute definitions - even the attributes with the same names would be actually unrelated; models induced from the training data would be completely useless on the testing data, as none of its attributes would be recognized. So, to tell Orange to reuse the attributes, you can use the <code>use</code> keyword:</p>

<XMP class="code">
>>> train = orange.ExampleTable("breast.xls#train")
>>> test = orange.ExampleTable("breast.xls#test", \
              use = train.domain)
</XMP>

<p>By this, Orange is licensed to reuse any of attributes, either normal or meta, when constructing the domain for testing examples. Instead of giving a domain, you can also pass a list of attributes:</p>

<XMP class="code">
>>> train = orange.ExampleTable("breast.xls#train")
>>> test = orange.ExampleTable("breast.xls#test", \
            use = train.domain.attributes + someother.domain.attributes)
</XMP>

<p>Finally, you can tell Orange to reuse a domain.</p>

<XMP class="code">
>>> train = orange.ExampleTable("breast.xls#train")
>>> test = orange.ExampleTable("breast.xls#test", domain = some.domain)
</XMP>

<p>Here, <code>some.domain</code> does not need to be a domain that was constructed when loading data from files. If the given domain cannot be reused, an error is reported.</p>

<P>Saving and reusing domain descriptors is handled through instances of class <A href="DomainDepot.htm"><CODE>DomainDepot</CODE></A>. Basically, each file type has its own instance of <CODE>DomainDepot</CODE> that stores all active domains loaded from the files of corresponding type. If need arises, you can create new depots, for instance, if you program routines for reading additional file formats.</P>

<H2>Saving Examples</H2>

<P>Writing examples into files is even simpler - all you need to do is call <CODE>saveAssistant</CODE>, <CODE>saveC45</CODE>, <CODE>saveRetis</CODE> <CODE>saveTabDelimited</CODE> or <CODE>saveTxt</CODE>, passing a filename as the first and the examples as the second argument. The function will decorate the file name according to the format's customs. One-file formats (such as tab-delimited or basket) will be given the default extension (such as .tab or .basket) unless you provide one. For Assistant's format, the domain description file will always be prefixed with <CODE>asdo</CODE> and the data file with <CODE>asda</CODE>. For C45 and Retis, the domain definition files will be given extension .names and .rdo, respectively, while data files will be given the standard extensions (.data, .rda) only if the filename that you've given as argument doesn't have an extension (ie, doesn't have any dots to the left of the last path separator).</P>

<P>Some formats are not able to store all types of datasets. For instance, Retis can only store examples where the outcome is continuous. You cannot store the iris data with its three-valued discrete outcome as Retis file.</P>

<html>
<HEAD>
<LINK REL=StyleSheet HREF="../style.css" TYPE="text/css">
<LINK REL=StyleSheet HREF="style-print.css" TYPE="text/css" MEDIA=print></LINK>
</HEAD>

<BODY>
<h1>Attribute Descriptors</h1>

<P>Attribute descriptors are stored in objects derived from type 
<CODE>orange.Variable</CODE>. Their role is to identify the 
attributes. Two attributes in Orange are same, if they have the 
same descriptor, not the same name. Besides, descriptors store 
symbolic names for attributes and their symbolic values. Another 
important feature of <CODE>orange.Variable</CODE> is that define 
a method by which an attribute value can be computed from other 
attributes; this is used in, for instance, discretization.</P>

<H2>Variable</H2>

<P><CODE>orange.Variable</CODE> is a base class for attribute descriptors.</P>

<p class=section>Attributes</P>

<DL class=attributes>
<DT>name</DT>
<DD>
Each attribute has a name. An empty string is a wholly legal name 
that can and should be used for temporary or very internal 
attributes. Two attributes can have the same name: Orange does 
not distinguish attributes by names except in communication with 
user (when user wants to see a value of attribute 'age', the name 
is obviously used) or when loading the data (see the explanation 
in <A href="fileformats.htm">Supported File Formats</A>). 
However, if two attributes with same names appear in the same 
domain and indexing by names is used, results of user queries are 
unpredictable. In general, try to avoid giving the same name to 
different attributes.<DD>

<DT>varType</DT>
<DD><CODE>varType</CODE> is an integer describing the attribute 
type. As for <CODE>orange.Value</CODE>'s <CODE>varType</CODE>, it 
can be <code>orange.VarTypes.Discrete</code> (1), 
<code>orange.VarTypes.Continuous</code> (2) or 
<code>orange.VarTypes.Other</code>.</DD>

<DT>getValueFrom</DT>
<DD>When attribute is derived from other attributes, e.g. through 
discretization, binarization or some form of constructive 
induction, <CODE>getValueFrom</CODE> points to a "function" that 
computes the value of the attribute from values of other 
attributes. The function is actually an 
<CODE>orange.Classifier</CODE>: its input is an 
<CODE>orange.Example</CODE> whose values are used to compute the 
value of the derived attribute, and its result is the computed 
value. A great thing about this is that it usually happens behind 
your back. Even more, you should <B>never call 
<CODE>getValueFrom</CODE> directly, but should do so through 
method <CODE>computeValue</CODE> that establishes security 
measures prohibiting deadlocks.</B></P>

<P>Although <CODE>getValueFrom</CODE> is always of type 
<CODE>orange.Classifier</CODE>, you can set it to an ordinary 
Python function or callable class. Orange will automatically wrap 
it into an <CODE>orange.Classifier</CODE>, as described in <A 
href="callbacks.htm">Subtyping Orange classes in Python</A>.</P>

<P>See the corresponding example below.</P></DD>

<DT>ordered</DT>
<DD>A flag telling whether the attribute values are ordered. At 
the moment, no method actually treats ordinal attributes 
differently than nominal, so this flag is reserved for future 
use.</DD>

<DT>distributed</DT>
<DD>A flag that tells whether the values of this attribute are distributions. As for flag <CODE>ordered</CODE>, no methods treat such attributes in any special manner, so the flag is again reserved for future use.</DD>

<DT>sourceVariable</DT>
<DD>Another attribute for potential use in future: if 
<CODE>getValueFrom</CODE> computes the attribute value from a 
single attribute, this attribute can be (but is not necessarily) 
stored in <CODE>sourceVariable</CODE>. As this is only used in a 
rather obscure place you won't run into, there's no harm in not 
ever setting <CODE>sourceVariable</CODE>.</DD>
</DT>

<DT>randomGenerator</DT>
<DD>Local random number generator used by method <CODE>randomValue</CODE>.</DD>
</DL>

<p class=section>Methods</P>

<DL class=attributes>
<DT>&lt;constructors&gt;</DT>
<DD>Constructors for classes derived from 
<CODE>orange.Variable</CODE> (which is abstract itself) can be 
given the usual keyword arguments. Besides, the attribute name 
can be given directly. That is, an attribute descriptor for 
continuous attribute "age" can be constructed by calling 
<CODE>orange.FloatVariable("age")</CODE> or, equivalently, by 
<CODE>orange.FloatVariable(name="age")</CODE>.</DD>

<DT>&lt;call&gt;</DT>
<DD>Calling a descriptor can be used to convert symbolic, integer 
or any other applicable native Python types into 
<CODE>orange.Value</CODE> objects for this attribute. Calling 
<CODE>var(val)</CODE> is equivalent to <CODE>orange.Value(var, 
val)</CODE>; see <A href="value.htm#construction">construction of 
values</A>.</DD>

<DT>&lt;iteration&gt;</DT>
<DD>Attribute descriptors can be used in <CODE>for</CODE> loops. 
So <CODE>for val in var</CODE> would iterate through all values 
of attribute <CODE>var</CODE>, when possible.</DD>

<DT>randomValue()</DT>
<DD><CODE>randomValue</CODE> returns a random value for the attribute, when possible. This function uses <CODE>randomGenerator</CODE>; if none has been assigned yet, a new is constructed with the initial seed 0, and stored for the future use.</DD>

<DT>computeValue(example)</DT>
<DD>Calls <CODE>getValueFrom</CODE> through a mechanism that prevents deadlocks by circular calls.</DD>
</DL>

<A name="EnumVariable">
<H2>EnumVariable</H2>

<P><CODE>EnumVariable</CODE> is a descriptor for nominal and 
ordinal attributes. It defines two additional attributes, 
<CODE>values</CODE> and <CODE>baseValue</CODE>, and no additional 
methods. Iterating and returning random values is supported.

<p class=section>Attributes</p>

<DL class=attributes>
<DT>values</DT>
<DD>A list with symbolic names for attribute's values. Values for 
attributes of type <CODE>EnumVariable</CODE> are stored as 
integers referring to this list. Therefore, modifying this list 
instantly changes names of values of examples, as they are 
printed out or referred to by user. The size of the list is also 
used to indicate the number of possible values for this 
attribute; changing the size, especially <B>shrinking the list 
can have disastrous effects and is therefore not really 
recommendable</B>. You've been warned.</P>

<P>It is also assumed that <CODE>values</CODE> is always defined 
(but can be empty), so you should never set <CODE>values</CODE> 
to <CODE>None</CODE>.</dd>

<DT>baseValue</DT>
<DD>Sets the base value for the attribute. This can be, for 
instance a "normal" value, such as "no complications" as opposed 
to abnormal "low blood pressure" and "excessive blooding". The 
base value can be (and is) used by certain statistics and, 
potentially, learning algorithms. <CODE>baseValue</CODE> is an 
integer that is to be interpreted as an index to 
<CODE>values</CODE>. The absence of base value ("sex" can be 
either "female" or "male", without an obvious base value) is 
indicated by <CODE>-1</CODE>.</DD> </DL>

<A name="FloatVariable">
<H2>FloatVariable</H2>


<P><CODE>FloatVariable</CODE> is a descriptor for continuous 
attributes.

<DL class=attributes>
<DT>startValue, endValue, stepValue</DT>
<DD>The range of attribute, used for returning random values and for iteration. You can leave 
the three values at defaults (<CODE>-1</CODE>, which is 
interpreted as undefined), if you don't need randoms and 
iterations. (I can't recall ever using them...)</DD>

<DT>numberOfDecimals</DT>
<DD>The number of decimals used when the value is printed, converted to a string or saved to a file</DD>

<DT>scientificFormat</DT>
<DD>If <CODE>True</CODE>, the value is printed in scientific format whenever it would have more than 5 digits. In this case, <CODE>numberOfDecimals</CODE> is ignored.</DD>

<DT>adjustDecimals</DT>
<DD>Tells Orange to monitor the number of decimals when the value is converted from a string (either by setting the attribute values, <I>e.g.</I> <CODE>example[0]="3.14"</CODE> or when reading from file). The value of 0 means that the number of decimals should not be adjusted, while 1 and 2 mean that adjustments are on, with 2 denoting that no values have been converted yet.</DD>
</DL>

<P>By default, adjustment of number of decimals goes as follows. If the attribute was constructed when examples were read from a file, it will be printed with the same number of decimals as the largest number of decimals encountered in the file. If scientific notation occurs in the file, <CODE>scientificFormat</CODE> will be set to True and scientific format will be used for values too large or too small.</P>

<P>If the attribute is created in a script, it will have, by default, three decimals places. This can be changed either by setting the attribute value from a string (<I>e.g.</I> <CODE>example[0]="3.14"</CODE>, but not <CODE>example[0]=3.14</CODE>) or by manually setting the <CODE>numberOfDecimals</CODE> (<I>e.g.</I> <CODE>attr.numberOfDecimals=1</CODE>).</P>

<A name="StringVariable">
<H2>StringVariable</H2>

<P><CODE>StringVariable</CODE> describes attributes that contains 
strings. No method can use them for learning; some will complain 
and other will silently ignore them when the encounter them. They 
can be, however, useful for meta-attributes; if examples in 
dataset have unique id's, the most efficient way to retain them 
is to read them as meta-attributes. In general, never use 
discrete attributes with many (say, more than 50) values. Such 
attributes are probably not of any use for learning and should be 
stored as string attributes.</P>

<P>There's a short and simple example which makes use of 
<CODE>StringVariable</CODE> near the end of the page about <a 
href="Domain.htm"><CODE>Domain</CODE></A>.</P>


<H2>PythonVariable</H2>

<P><CODE>PythonVariable</CODE> is a base class for descriptors defined in Python. Itself fully functional, <CODE>PythonVariable</CODE> can already be used as a descriptor for attributes that contain arbitrary Python values. Since this is an advanced topic, <CODE>PythonVariable</CODE>s are described on a <A href="PythonVariable.htm">a separate page</A>.

<A name="getValueFrom">
<H2>Using getValueFrom</H2>

<P>Monk 1 is a well-known dataset with target concept <CODE>y := 
a==b or e==1</CODE>. It does not hurt, even more, it can even 
help if we replace the four-valued attribute <CODE>e</CODE> with 
a binary attribute having values <CODE>1</CODE> and <CODE>not 
1</CODE>. The new attribute shall be computed from the old one on 
the fly.</P>

<p class="header">part of <a href="variable.py">variable.py</a>
(uses <a href="monk1.tab">monk1.tab</a>)</p>
<XMP class="code">
import orange
data = orange.ExampleTable("monk1")

e2 = orange.EnumVariable("e2", values = ["not 1", "1"])

def checkE(example, returnWhat):
    if example["e"]=="1":
        return orange.Value(e2, "1")
    else:
        return orange.Value(e2, "not 1")

e2.getValueFrom = checkE
</XMP>
</P>

<P>Our new attribute is named <CODE>e2</CODE>; we define it by 
descriptor of type <CODE>orange.EnumVariable</CODE>, with 
appropriate name and values <CODE>not 1</CODE> and <CODE>1</CODE> (we chose this order so that the <CODE>not 1</CODE>'s index is 0, which can be, if needed, interpreted as <CODE>false</CODE>).</P>

<P><CODE>checkE</CODE> is a function that is passed an example 
and another argument we don't care about. If example's attribute 
<CODE>e</CODE> equals <CODE>1</CODE>, the function returns value 
<CODE>1</CODE>, otherwise it returns <CODE>not 1</CODE>. Both are returned as values, not plain strings of attribute 
<CODE>e2</CODE>. Finally, we tell <CODE>e2</CODE> to use 
<CODE>checkE</CODE> to compute its value when needed, by 
assigning <CODE>checkE</CODE> to <CODE>getValueFrom</CODE>.</P>

<P>In most circumstances, value of <CODE>e2</CODE> can be computed on the fly - we can pretend that the attribute exists in the <CODE>data</CODE>, although it doesn't (but can be computed from it). For instance, we can observe the conditional distribution of classes with regard to <CODE>e2</CODE>.</P>

<XMP class="code">
>>> dist = orange.Distribution(e2, data)
>>> print dist
<324.000, 108.000>
>>>
>>> cont = orange.ContingencyAttrClass(e2, data)
>>> print "Class distribution when e=1:", cont["1"]
Class distribution when e=1: <0.000, 108.000>
>>> print "Class distribution when e<>1:", cont["not 1"]
Class distribution when e<>1: <216.000, 108.000>
</XMP>

<P><CODE>orange.Distribution</CODE> is called to compute the distribution for <CODE>e2</CODE> in <CODE>data</CODE>. When it notices that <CODE>data.domain</CODE> does not contain <CODE>e2</CODE>, it checks whether <CODE>e2</CODE>'s <CODE>getValueFrom</CODE> is defined and, seeing that it is, utilizes it to get <CODE>e2</CODE>'s values.</P>

<P>We describe technical details to make you aware that automatic recomputation requires some effort on the side of <CODE>orange.ContingencyAttrClass</CODE>. There are methods which will not do that for you, either because it would be too complex or time consuming. An example of such situation is constructive induction by function decomposition; making incompatibility matrices with attributes computed on the fly would be slow and impractical, so attempting it would yield an error. In such cases, you can simply convert entire examples table to a new domain that also includes the new attribute.</P>

<p class="header">part of <a href="variable.py">variable.py</a>
(uses <a href="monk1.tab">monk1.tab</a>)</p>
<XMP class="code">
newDomain = orange.Domain([data.domain["a"], data.domain["b"],
                           e2, data.domain.classVar])
newData = orange.ExampleTable(newDomain, data)
</XMP>
</P>

<P>Automatic computation is useful when the data is split onto training and testing examples. Training examples can be modified by adding, removing and transforming attributes (in a typical setup, continuous attributes are discretized prior to learning, therefore the original attributes are replaced by new attributes), while testing examples are left as they are. When they are classified, the classifier automatically converts the testing examples into the new domain, which includes recomputation of transformed attributes. With our toy script, we can split the data, use it for learning and then test the classification of unmodified test examples.</P>

<p class="header"><a href="variable2.py">variable2.py</a>
(uses <a href="monk1.tab">monk1.tab</a>)</p>
<XMP class="code">
import orange, orngTree

data = orange.ExampleTable("monk1")

indices = orange.MakeRandomIndices2(data, p0=0.7)
trainData = data.select(indices, 0)
testData = data.select(indices, 1)

e2 = orange.EnumVariable("e2", values = ["not 1", "1"])
e2.getValueFrom = lambda example, returnWhat: orange.Value(e2, example["e"]=="1")

newDomain = orange.Domain([data.domain["a"], data.domain["b"], e2, data.domain.classVar])
newTrain = orange.ExampleTable(newDomain, trainData)

tree = orange.TreeLearner(newTrain)

orngTree.printTxt(tree)

for ex in testData[:10]:
    print ex.getclass(), tree(ex)
</XMP>
</P>

<P>First, note that we have rewritten the above example, 
replacing the <CODE>checkE</CODE> function with a simpler 
<CODE>lambda function</CODE>, which exploits the fact that 
Python's <CODE>false</CODE> and <CODE>true</CODE> equal 0 and 1. 
We have split the <CODE>data</CODE> into <CODE>trainData</CODE> 
and <CODE>testData</CODE>, with 70% and 30% of examples, 
respectively. After constructing a new domain, we only translate 
the training examples and induce a decision tree. Printout shows 
that it first split the examples by the attribute <CODE>e2</CODE> 
and then, if <CODE>e2</CODE> is not 1, it (implicitly) checks the 
equality of <CODE>a</CODE> and <CODE>b</CODE>. In the 
<CODE>for</CODE> loop, examples from <CODE>testData</CODE>, which 
does not have attribute <CODE>e2</CODE> are correctly classified. 
The way this is done is same for all classifiers: classifier 
stores the domain description for the learning examples (or, to 
be more precise, a domain in which the model is described). Prior 
to classification, examples from other domains are converted to 
the stored domain. In our case, examples from 
<CODE>testData</CODE> are converted to <CODE>newDomain</CODE>, 
and the given lambda function is used to compute the value from 
<CODE>e2</CODE> from <CODE>e</CODE>.</P>

<P>What to do if an attribute can be computed from different 
domains, using different procedures? Can there be more than one 
function to be tried? Why is there only one 
<CODE>getValueFrom</CODE>, not a list of them? Although we are 
pretty advanced Orange users, we never ran into a situation where 
we needed this (obviously; if needed it, we'd have done something 
about it :). If you, however, need to specify more than one 
function for attribute value computation, you can define a Python 
class that stores a list of functions and calls them in 
appropriate manner. Then give an object of this class to 
<CODE>getValueFrom</CODE>. And tell us about your case, and we 
shall rethink our position.</P>

</BODY> 
